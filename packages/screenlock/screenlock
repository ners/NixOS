#!/usr/bin/env python3

import subprocess
from i3ipc import Connection
from PIL import Image
import io
import os

import pprint
pp = pprint.PrettyPrinter()

pprint = pp.pprint

sway = Connection()

bgfile = '/tmp/lock.jpg'

def rect_to_area(rect, scale):
    x = rect['x'] * scale
    y = rect['y'] * scale
    width = rect['width'] * scale
    height = rect['height'] * scale
    return (round(x), round(y), round(x + width), round(y + height))

def fetch_windows():
    tree = sway.get_tree().ipc_data
    areas = []
    for output in tree['nodes']:
        output_rect = output['rect']
        scale = output.get('scale', 1.0)
        print('Output:', output.get('name', 'NONAME'), 'rect:', output_rect, 'scale:', scale)
        bar = None
        for workspace in output.get('nodes', []):
            workspace_active = False
            workspace_rect = workspace['rect']
            if not 'num' in workspace:
                continue
            print('  Workspace', workspace['num'], workspace_rect)
            queue = workspace.get('nodes', []) + workspace.get('floating_nodes', [])
            bar_height = output_rect['height'] - workspace_rect['height']
            bar = {
                'width': output['rect']['width'],
                'height': bar_height,
                'x': 0,
                'y': output_rect['height'] - bar_height if output_rect['y'] == workspace_rect['y'] else 0,
            }
            while len(queue) > 0:
                node = queue.pop(0)
                queue.extend(node.get('nodes', []))
                queue.extend(node.get('floating_nodes', []))
                if node.get('visible', False):
                    rect = node['rect']
                    area = rect_to_area(rect, scale)
                    print('    Window:', rect)
                    areas.append(area)
                    workspace_active = True
                if workspace_active and 'deco_rect' in node:
                    rect = node['deco_rect']
                    print('    Deco:', rect)
                    area = rect_to_area(rect, scale)
                    areas.append(area)
        if bar:
            print('  Bar:', bar)
            areas.append(rect_to_area(bar, scale))
    return areas

def screenshot():
    content = subprocess.run(['grim', '-t', 'ppm', '-'], stdout=subprocess.PIPE).stdout
    return Image.open(io.BytesIO(content))

def obscure_image(image):
  size = image.size
  pixel_size = 8

  if size[0] < pixel_size or size[1] < pixel_size:
    return image

  image = image.resize(
          (int(size[0] / pixel_size), int(size[1] / pixel_size)),
          Image.NEAREST)

  image = image.resize(
          (int(size[0]), int(size[1])),
          Image.NEAREST)
  return image

def obscure(image, areas):
    for area in areas:
        subimage = obscure_image(image.crop(area))
        image.paste(subimage, area)
    return image

def lock_screen():
  subprocess.run([
      'swaylock',
      '-i', bgfile,
      '--indicator-radius', '30',
      '--ring-color', 'FFFFFF',
      '--key-hl-color', '333333'])

if __name__ == '__main__':
  # 1: Take a screenshot.
  scr = screenshot()

  # 2: Get the visible windows.
  areas = fetch_windows()

  # 3: Process and save the screenshot.
  scr = obscure(scr, areas)
  scr.save(bgfile)

  # 4: Lock the screen
  lock_screen()

  # 5: Remove the file
  os.remove(bgfile)
